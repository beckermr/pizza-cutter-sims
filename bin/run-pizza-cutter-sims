#!/usr/bin/env python
import sys
import time
import copy
import logging
import concurrent.futures

import click
import yaml
import numpy as np

import fitsio
from esutil.numpy_util import combine_arrlist
from esutil.pbar import PBar

# used to get the DEBUG_PLOT logging level
import pizza_cutter  # noqa

from pizza_cutter_sims.run_utils import (
    estimate_m_and_c,
    backend_pool,
    cut_nones,
    get_n_workers,
)


def _run_sets_of_pairs(all_args):
    return [_run_pair(arg) for arg in all_args]


def _run_pair(args):
    import numpy as np
    from pizza_cutter_sims.main import run_end2end_pair_with_shear
    from pizza_cutter_sims.run_utils import measure_shear_metadetect

    def _is_none(res):
        if res is None:
            return True

        if any(res[k] is None for k in res):
            return True

        return False

    try:
        kwargs, num, backend, start_time = args

        pres, mres = run_end2end_pair_with_shear(**kwargs)

        if _is_none(pres) or _is_none(mres):
            return None, None

        fkeys = ["g1p", "g1m", "g1", "g2p", "g2m", "g2"]
        ikeys = ["s2n_cut", "ormask_cut", "mfrac_cut"]
        dtype = []
        for key in fkeys:
            dtype.append((key, "f8"))
        for key in ikeys:
            dtype += [(key, "i4")]

        datap = []
        datam = []
        for ormask_cut in [True, False]:
            for s2n_cut in [10, 15, 20]:
                pgm = measure_shear_metadetect(
                    pres, s2n_cut=s2n_cut, t_ratio_cut=1.2,
                    ormask_cut=ormask_cut, mfrac_cut=None,
                )
                mgm = measure_shear_metadetect(
                    mres, s2n_cut=s2n_cut, t_ratio_cut=1.2,
                    ormask_cut=ormask_cut, mfrac_cut=None,
                )
                if pgm is None or mgm is None:
                    continue

                datap.append(tuple(list(pgm) + [s2n_cut, 0 if ormask_cut else 1, -1]))
                datam.append(tuple(list(mgm) + [s2n_cut, 0 if ormask_cut else 1, -1]))

        for mfrac_cut in [0, 1, 2, 5, 8, 10, 20, 50, 80, 100]:
            for s2n_cut in [10, 15, 20]:
                pgm = measure_shear_metadetect(
                    pres, s2n_cut=s2n_cut, t_ratio_cut=1.2,
                    ormask_cut=False, mfrac_cut=mfrac_cut/100,
                )
                mgm = measure_shear_metadetect(
                    mres, s2n_cut=s2n_cut, t_ratio_cut=1.2,
                    ormask_cut=False, mfrac_cut=mfrac_cut/100,
                )
                if pgm is None or mgm is None:
                    continue

                datap.append(tuple(list(pgm) + [s2n_cut, -1, mfrac_cut]))
                datam.append(tuple(list(mgm) + [s2n_cut, -1, mfrac_cut]))

        if backend == "mpi":
            print(
                "[% 10ds] did %04d" % (time.time() - start_time, num+1),
                flush=True,
            )

        return np.array(datap, dtype=dtype), np.array(datam, dtype=dtype)
    except KeyError:
        raise
    except TypeError:
        raise
    except Exception as e:
        import traceback
        print("sim failed: %s\n%s" % (repr(e), traceback.format_exc()), flush=True)
        return None, None


def _measure_m_c(outputs, cfg, write=None):
    pdata, mdata = zip(*outputs)
    pdata, mdata = cut_nones(pdata, mdata)
    if len(pdata) > 0 and len(mdata) > 0:
        pdata = combine_arrlist(list(pdata))
        mdata = combine_arrlist(list(mdata))

        pmsk = (pdata["s2n_cut"] == 10) & (pdata["ormask_cut"] == 0)
        _pdata = pdata[pmsk]
        _mdata = mdata[pmsk]

        pres = [
            (
                _pdata["g1p"][i], _pdata["g1m"][i], _pdata["g1"][i],
                _pdata["g2p"][i], _pdata["g2m"][i], _pdata["g2"][i],
            )
            for i in range(pdata[pmsk].shape[0])
        ]

        mres = [
            (
                _mdata["g1p"][i], _mdata["g1m"][i], _mdata["g1"][i],
                _mdata["g2p"][i], _mdata["g2m"][i], _mdata["g2"][i],
            )
            for i in range(pdata[pmsk].shape[0])
        ]

        if write is None:
            print("\n", flush=True, end="")

        m, msd, c, csd = estimate_m_and_c(
            pres,
            mres,
            cfg["shear"]["g"],
            swap12=cfg["shear"]["swap12"],
        )

        msg = """\
# of sims: {n_sims}
noise cancel m   : {m: f} +/- {msd: f} [1e-3, 3-sigma]
noise cancel c   : {c: f} +/- {csd: f} [1e-5, 3-sigma]""".format(
                n_sims=len(pres),
                m=m/1e-3,
                msd=msd/1e-3 * 3,
                c=c/1e-5,
                csd=csd/1e-5 * 3,
        )
        if write is None:
            print(msg, flush=True)
        else:
            write(msg)

        return pdata, mdata
    else:
        return None


@click.command()
@click.option('--config', type=str, default="config.yaml", help='config file')
@click.option('--seed', type=int, default=None, help='seed for the RNG', required=True)
@click.option('--output', type=str, default=None, help='output file')
@click.option('--n-sims', type=int, default=1, help='number of sims to run')
@click.option(
    '--log-level', default='warning', type=str,
    help=(
        'python logging level [one of critical error, '
        'warning, info, or debug]')
)
@click.option(
    '--backend', default='sequential', type=str,
    help=(
        "parallel backend to use (one of 'sequential', "
        "'loky', 'multiprocessing', 'condor', or 'mpi')"
    )
)
@click.option(
    '--n-workers', default=None, type=int,
    help="number of parallel workers to use",
)
@click.option(
    '--n-report', default=None, type=int,
    help="number of subiterations between which to report results",
)
@click.option(
    '--n-pack', default=1, type=int,
    help="number of sims to pack in a single job",
)
def main(config, seed, output, n_sims, log_level, backend, n_workers, n_report, n_pack):
    """Run simulation(s) and analyze them with pizza cutter coadding and metadetect."""

    start_time = time.time()

    if backend == "sequential" or backend == "local":
        logging.basicConfig(stream=sys.stdout)
        for code in ["ngmix", "metadetect", "pizza_cutter", "pizza_cutter_sims"]:
            logging.getLogger(code).setLevel(
                getattr(logging, log_level.upper()))

    if backend == "mpi":
        from mpi4py import MPI
        comm = MPI.COMM_WORLD
        rank = comm.Get_rank()
    else:
        rank = 0

    if rank == 0:
        with open(config, "r") as fp:
            cfg = yaml.safe_load(fp.read())

        rng = np.random.RandomState(seed=seed)
        sim_rng_seeds = rng.randint(low=1, high=2**29, size=n_sims)
        gal_rng_seeds = rng.randint(low=1, high=2**29, size=n_sims)
        coadd_rng_seeds = rng.randint(low=1, high=2**29, size=n_sims)
        mdet_rng_seeds = rng.randint(low=1, high=2**29, size=n_sims)
        star_rng_seeds = rng.randint(low=1, high=2**29, size=n_sims)

        args = []
        for i, (
            rng_seed, gal_rng_seed, star_rng_seed,
            coadd_rng_seed, mdet_rng_seed
        ) in enumerate(
            zip(
                sim_rng_seeds, gal_rng_seeds, star_rng_seeds,
                coadd_rng_seeds, mdet_rng_seeds,
            )
        ):
            args.append((
                dict(
                    rng_seed=rng_seed,
                    gal_rng_seed=gal_rng_seed,
                    star_rng_seed=star_rng_seed,
                    coadd_rng_seed=coadd_rng_seed,
                    mdet_rng_seed=mdet_rng_seed,
                    cfg=copy.deepcopy(cfg),
                    g1=cfg["shear"]["g"],
                    g2=0,
                    swap12=cfg["shear"]["swap12"],
                ),
                i,
                backend,
                start_time,
            ))
    else:
        args = []

    if n_report is None:
        n_report = len(args) // 100
    if n_report < 100:
        n_report = 100

    n_chunks = n_sims // n_pack
    if n_chunks * n_pack < n_sims:
        n_chunks += 1

    n_report_chunks = n_report // n_pack
    if n_report_chunks < 1:
        n_report_chunks = 1

    if n_workers is None:
        n_workers = min(n_report_chunks, get_n_workers(backend))

    if backend == "local":
        if rank == 0:
            outputs = []
            for chunk in range(n_chunks):
                start = chunk * n_pack
                end = min(start + n_pack, len(args))
                outputs += _run_sets_of_pairs(args[start:end])

                n_outputs = len(outputs)
                if n_outputs % n_report == 0 and n_outputs > 0:
                    res = _measure_m_c(outputs, cfg)
                    if output is not None and res is not None:
                        with fitsio.FITS(output, 'rw', clobber=True) as fits:
                            fits.write(res[0], extname='plus')
                            fits.write(res[1], extname='minus')
    else:
        with backend_pool(
            backend,
            n_workers=n_workers,
            verbose=100,
        ) as pool:
            if hasattr(pool, "submit"):
                futs = []
                for chunk in range(n_chunks):
                    start = chunk * n_pack
                    end = min(start + n_pack, len(args))
                    futs.append(_run_sets_of_pairs, args[start:end])

                outputs = []
                for i in PBar(
                    range(len(futs)), total=len(futs), n_bars=79, desc='running jobs'
                ):
                    ok = False
                    while not ok:
                        for k in range(len(futs)):
                            f = futs[k]
                            f.done()
                            try:
                                res = f.result(timeout=1)
                                ok = True
                                break
                            except Exception as e:
                                if isinstance(e,  concurrent.futures.TimeoutError):
                                    continue
                                else:
                                    res = []
                                    ok = True
                                    break

                    if ok:
                        futs.pop(k)
                        outputs += res

                    n_outputs = len(outputs)
                    if n_outputs % n_report == 0 and n_outputs > 0 and rank == 0:
                        print("\n", flush=True, end="")
                        res = _measure_m_c(outputs, cfg)
                        if output is not None and res is not None:
                            with fitsio.FITS(output, 'rw', clobber=True) as fits:
                                fits.write(res[0], extname='plus')
                                fits.write(res[1], extname='minus')
            else:
                outputs = []
                curr_args = []
                for chunk in PBar(range(n_chunks), n_bars=79, desc='running chunks'):
                    start = chunk * n_pack
                    end = min(start + n_pack, len(args))
                    curr_args.append(args[start:end])

                    if (
                        (
                            chunk % n_report_chunks == 0
                            and chunk > 0
                        )
                        or chunk == n_chunks-1
                    ):
                        if backend in ["dask", "loky"]:
                            print("\n", flush=True, end="")

                        for out in pool.map(_run_sets_of_pairs, curr_args):
                            outputs += out

                        curr_args = []

                    n_outputs = len(outputs)
                    if rank == 0 and n_outputs % n_report > 0 and n_outputs > 0:
                        res = _measure_m_c(outputs, cfg)
                        if output is not None and res is not None:
                            with fitsio.FITS(output, 'rw', clobber=True) as fits:
                                fits.write(res[0], extname='plus')
                                fits.write(res[1], extname='minus')

    if rank == 0:
        res = _measure_m_c(outputs, cfg)
        if output is not None and res is not None:
            with fitsio.FITS(output, 'rw', clobber=True) as fits:
                fits.write(res[0], extname='plus')
                fits.write(res[1], extname='minus')


if __name__ == '__main__':
    main()

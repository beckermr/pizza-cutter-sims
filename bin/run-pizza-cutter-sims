#!/usr/bin/env python
import sys
import copy
import logging
import concurrent.futures

import click
import yaml
import numpy as np

import fitsio
from esutil.numpy_util import combine_arrlist
from esutil.pbar import PBar

# used to get the DEBUG_PLOT logging level
import pizza_cutter  # noqa

from pizza_cutter_sims.run_utils import (
    estimate_m_and_c,
    backend_pool,
    cut_nones,
    get_n_workers,
)


def _run_sets_of_pairs(all_args):
    def _run_pair(args):
        import numpy as np
        from pizza_cutter_sims.main import run_end2end_pair_with_shear
        from pizza_cutter_sims.run_utils import measure_shear_metadetect

        def _is_none(res):
            if res is None:
                return True

            if any(res[k] is None for k in res):
                return True

            return False

        try:
            kwargs, num = args

            pres, mres = run_end2end_pair_with_shear(**kwargs)

            if _is_none(pres) or _is_none(mres):
                return None, None

            fkeys = ["g1p", "g1m", "g1", "g2p", "g2m", "g2"]
            ikeys = ["s2n_cut", "ormask_cut", "mfrac_cut"]
            dtype = []
            for key in fkeys:
                dtype.append((key, "f8"))
            for key in ikeys:
                dtype += [(key, "i4")]

            datap = []
            datam = []
            for ormask_cut in [True, False]:
                for s2n_cut in [7, 8, 9, 10, 15, 20]:
                    pgm = measure_shear_metadetect(
                        pres, s2n_cut=s2n_cut, t_ratio_cut=1.2,
                        ormask_cut=ormask_cut, mfrac_cut=None,
                    )
                    mgm = measure_shear_metadetect(
                        mres, s2n_cut=s2n_cut, t_ratio_cut=1.2,
                        ormask_cut=ormask_cut, mfrac_cut=None,
                    )
                    if pgm is None or mgm is None:
                        continue

                    datap.append(
                        tuple(list(pgm) + [s2n_cut, 0 if ormask_cut else 1, -1]))
                    datam.append(
                        tuple(list(mgm) + [s2n_cut, 0 if ormask_cut else 1, -1]))

            for mfrac_cut in [0, 1, 2, 5, 8, 10, 20, 50, 80, 100]:
                for s2n_cut in [10, 15, 20]:
                    pgm = measure_shear_metadetect(
                        pres, s2n_cut=s2n_cut, t_ratio_cut=1.2,
                        ormask_cut=False, mfrac_cut=mfrac_cut/100,
                    )
                    mgm = measure_shear_metadetect(
                        mres, s2n_cut=s2n_cut, t_ratio_cut=1.2,
                        ormask_cut=False, mfrac_cut=mfrac_cut/100,
                    )
                    if pgm is None or mgm is None:
                        continue

                    datap.append(tuple(list(pgm) + [s2n_cut, -1, mfrac_cut]))
                    datam.append(tuple(list(mgm) + [s2n_cut, -1, mfrac_cut]))

            return np.array(datap, dtype=dtype), np.array(datam, dtype=dtype)
        except KeyError:
            raise
        except TypeError:
            raise
        except Exception as e:
            import traceback
            print("sim failed: %s\n%s" % (repr(e), traceback.format_exc()), flush=True)
            return None, None

    return [_run_pair(arg) for arg in all_args]


def _measure_m_c(outputs, cfg):
    pdata, mdata = zip(*outputs)
    pdata, mdata = cut_nones(pdata, mdata)
    if len(pdata) > 0 and len(mdata) > 0:
        pdata = combine_arrlist(list(pdata))
        mdata = combine_arrlist(list(mdata))

        pmsk = (pdata["s2n_cut"] == 10) & (pdata["ormask_cut"] == 0)
        _pdata = pdata[pmsk]
        _mdata = mdata[pmsk]

        pres = [
            (
                _pdata["g1p"][i], _pdata["g1m"][i], _pdata["g1"][i],
                _pdata["g2p"][i], _pdata["g2m"][i], _pdata["g2"][i],
            )
            for i in range(pdata[pmsk].shape[0])
        ]

        mres = [
            (
                _mdata["g1p"][i], _mdata["g1m"][i], _mdata["g1"][i],
                _mdata["g2p"][i], _mdata["g2m"][i], _mdata["g2"][i],
            )
            for i in range(pdata[pmsk].shape[0])
        ]

        m, msd, c, csd = estimate_m_and_c(
            pres,
            mres,
            cfg["shear"]["g"],
            swap12=cfg["shear"]["swap12"],
            jackknife=200 if len(pres) >= 200 else None,
        )

        msg = """\
# of sims: {n_sims}
noise cancel m   : {m: f} +/- {msd: f} [1e-3, 3-sigma]
noise cancel c   : {c: f} +/- {csd: f} [1e-5, 3-sigma]""".format(
                n_sims=len(pres),
                m=m/1e-3,
                msd=msd/1e-3 * 3,
                c=c/1e-5,
                csd=csd/1e-5 * 3,
        )
        print(msg, flush=True)

        return pdata, mdata
    else:
        return None


def _gen_args(
    start, end, cfg,
    sim_rng_seeds, gal_rng_seeds, star_rng_seeds, coadd_rng_seeds, mdet_rng_seeds
):

    def _gen():
        for i in range(start, end):
            yield (
                dict(
                    rng_seed=sim_rng_seeds[i],
                    gal_rng_seed=gal_rng_seeds[i],
                    star_rng_seed=star_rng_seeds[i],
                    coadd_rng_seed=coadd_rng_seeds[i],
                    mdet_rng_seed=mdet_rng_seeds[i],
                    cfg=copy.deepcopy(cfg),
                    g1=cfg["shear"]["g"],
                    g2=0,
                    swap12=cfg["shear"]["swap12"],
                ),
                i,
            )

    return _gen


@click.command()
@click.option('--config', type=str, default="config.yaml", help='config file')
@click.option('--seed', type=int, default=None, help='seed for the RNG', required=True)
@click.option('--output', type=str, default=None, help='output file')
@click.option('--n-sims', type=int, default=1, help='number of sims to run')
@click.option(
    '--log-level', default='warning', type=str,
    help=(
        'python logging level [one of critical error, '
        'warning, info, or debug]')
)
@click.option(
    '--backend', default='local', type=str,
    help=(
        "parallel backend to use (one of 'local', "
        "'loky', 'condor', 'lsf', or 'mpi')"
    )
)
@click.option(
    '--n-workers', default=None, type=int,
    help="number of parallel workers to use",
)
@click.option(
    '--n-report', default=None, type=int,
    help="number of subiterations between which to report results",
)
@click.option(
    '--n-pack', default=1, type=int,
    help="number of sims to pack in a single job",
)
def main(config, seed, output, n_sims, log_level, backend, n_workers, n_report, n_pack):
    """Run simulation(s) and analyze them with pizza cutter coadding and metadetect."""

    if backend == "local":
        logging.basicConfig(stream=sys.stdout)
        for code in ["ngmix", "metadetect", "pizza_cutter", "pizza_cutter_sims"]:
            logging.getLogger(code).setLevel(
                getattr(logging, log_level.upper()))

    if backend == "mpi":
        from mpi4py import MPI
        comm = MPI.COMM_WORLD
        rank = comm.Get_rank()
    else:
        rank = 0

    if rank == 0:
        with open(config, "r") as fp:
            cfg = yaml.safe_load(fp.read())

        rng = np.random.RandomState(seed=seed)
        sim_rng_seeds = rng.randint(low=1, high=2**29, size=n_sims)
        gal_rng_seeds = rng.randint(low=1, high=2**29, size=n_sims)
        coadd_rng_seeds = rng.randint(low=1, high=2**29, size=n_sims)
        mdet_rng_seeds = rng.randint(low=1, high=2**29, size=n_sims)
        star_rng_seeds = rng.randint(low=1, high=2**29, size=n_sims)

    if n_report is None:
        n_report = max(n_sims // 100, 100)

    n_chunks = n_sims // n_pack
    if n_chunks * n_pack < n_sims:
        n_chunks += 1

    n_report_chunks = n_report // n_pack
    if n_report_chunks * n_pack < n_report:
        n_report_chunks += 1
    if n_report_chunks < 1:
        n_report_chunks = 1

    if n_workers is None:
        if backend == "condor":
            n_workers = min(10000, n_chunks)
        elif backend == "lsf":
            n_workers = min(5000, n_chunks)
        else:
            n_workers = min(n_report_chunks, get_n_workers(backend))

    print(
        "running %d sims w/ %d chunks reporting every %d chunks on %d workers" % (
            n_sims,
            n_chunks,
            n_report_chunks,
            n_workers,
        ),
        flush=True,
    )

    if backend == "local":
        if rank == 0:
            outputs = []
            for chunk in PBar(
                range(n_chunks),
                total=n_chunks, n_bars=79, desc='running jobs'
            ):
                start = chunk * n_pack
                end = min(start + n_pack, n_sims)
                _agen = _gen_args(
                    start,
                    end,
                    cfg,
                    sim_rng_seeds,
                    gal_rng_seeds,
                    star_rng_seeds,
                    coadd_rng_seeds,
                    mdet_rng_seeds,
                )
                outputs += _run_sets_of_pairs([a for a in _agen()])

                n_outputs = len(outputs)
                if (
                    (chunk+1) % n_report_chunks == 0
                    and n_outputs > 0
                ):
                    print("\n", end="", flush=True)
                    res = _measure_m_c(outputs, cfg)
                    if output is not None and res is not None:
                        with fitsio.FITS(output, 'rw', clobber=True) as fits:
                            fits.write(res[0], extname='plus')
                            fits.write(res[1], extname='minus')
    else:
        with backend_pool(
            backend,
            n_workers=n_workers,
            verbose=100,
        ) as pool:
            if pool is not None and rank == 0:
                run_futs = set()
                done_futs = set()
                outputs = []
                curr_chunk = 0
                for chunk in PBar(
                    range(n_chunks), total=n_chunks, desc="running jobs"
                ):
                    # submit while we can
                    while len(run_futs) < n_workers and curr_chunk < n_chunks:
                        start = curr_chunk * n_pack
                        end = min(start + n_pack, n_sims)
                        _agen = _gen_args(
                            start,
                            end,
                            cfg,
                            sim_rng_seeds,
                            gal_rng_seeds,
                            star_rng_seeds,
                            coadd_rng_seeds,
                            mdet_rng_seeds,
                        )
                        _args = [a for a in _agen()]
                        run_futs.add(pool.submit(_run_sets_of_pairs, _args))
                        curr_chunk += 1

                    # if we do not have results, wait, otherwise collect
                    if len(done_futs) == 0:
                        _done_futs, run_futs = concurrent.futures.wait(
                            run_futs,
                            return_when=concurrent.futures.FIRST_COMPLETED,
                        )
                        done_futs |= _done_futs
                    else:
                        fut = done_futs.pop()
                        ok = False
                        try:
                            res = fut.result()
                            ok = True
                        except Exception as e:
                            if isinstance(e,  concurrent.futures.TimeoutError):
                                continue
                            else:
                                print("\n" + str(e), flush=True)
                                res = []
                                ok = True
                        if ok:
                            outputs += res

                    # report m,c
                    n_outputs = len(outputs)
                    if (
                        (chunk+1) % n_report_chunks == 0
                        and n_outputs > 0
                    ):
                        print("\n", end="", flush=True)
                        res = _measure_m_c(outputs, cfg)
                        if output is not None and res is not None:
                            with fitsio.FITS(output, 'rw', clobber=True) as fits:
                                fits.write(res[0], extname='plus')
                                fits.write(res[1], extname='minus')

    if rank == 0:
        res = _measure_m_c(outputs, cfg)
        if output is not None and res is not None:
            with fitsio.FITS(output, 'rw', clobber=True) as fits:
                fits.write(res[0], extname='plus')
                fits.write(res[1], extname='minus')


if __name__ == '__main__':
    main()
